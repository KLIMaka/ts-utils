import Optional from "optional-js";
import { Deiterable } from "./collections";
import { Fn } from "./types";
export declare class Iter<T> implements Iterable<T> {
    iter: Iterable<T>;
    static of<T>(iter: Iterable<T>): Iter<T>;
    static range(start: number, end: number): Iter<number>;
    constructor(iter: Iterable<T>);
    [Symbol.iterator](): Iterator<T, any, any>;
    filter(f: (t: T) => boolean): Iter<T>;
    map<U>(f: (t: T) => U): Iter<U>;
    zip<T1>(it: Iterable<T1>): Iter<[T, T1]>;
    zip2<T1, T2>(it1: Iterable<T1>, it2: Iterable<T2>): Iter<[T, T1, T2]>;
    zip3<T1, T2, T3>(it1: Iterable<T1>, it2: Iterable<T2>, it3: Iterable<T3>): Iter<[T, T1, T2, T3]>;
    join(separator: T): Iter<T>;
    forEach(f: (t: T) => void): Iter<T>;
    enumerate(): Iter<[T, number]>;
    take(count: number): Iter<T>;
    skip(count: number): Iter<T>;
    skipWhile(f: (t: T) => boolean): Iter<T>;
    reduce(f: (lh: T, rh: T) => T, start: T): T;
    reduceFirst(f: (lh: T, rh: T) => T): Optional<T>;
    all(f: (t: T) => boolean): boolean;
    any(f: (t: T) => boolean): boolean;
    isEmpty(): boolean;
    first(f?: (t: T) => boolean): Optional<T>;
    chain(i: Iterable<T>): Iter<T>;
    butLast(): Iter<T>;
    flatten(): Iter<Deiterable<T>>;
    flatMap<U>(f: (t: T) => Iterable<U>): Iter<U>;
    collect(): T[];
    set(): Set<T>;
    length(): number;
    toMap<K, V>(keyMapper: Fn<T, K>, valueMapper: Fn<T, V>): Map<K, V>;
    toObject<U>(keyMapper: Fn<T, keyof U>, valueMapper: Fn<T, any>): U;
    group<K, V>(keyMapper: Fn<T, K>, valueMapper: Fn<T, V>): Map<K, V[]>;
    groupEntries<K, V>(keyMapper: Fn<T, K>, valueMapper: Fn<T, V>): Iter<[K, V[]]>;
    await_(): Promise<Iter<Awaited<T>>>;
}
export declare function iter<T>(iter: Iterable<T>): Iter<T>;
//# sourceMappingURL=iter.d.ts.map