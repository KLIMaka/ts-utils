export declare class VecStack {
    private stack;
    private sp;
    private spStack;
    private ssp;
    private gp;
    readonly one: number;
    readonly zero: number;
    readonly half: number;
    constructor(size: number);
    allocate(): number;
    allocateGlobal(): number;
    call<Args extends any[]>(f: (stack: VecStack, ...args: Args) => number, ...args: Args): number;
    callScalar<Args extends any[]>(f: (stack: VecStack, ...args: Args) => number, ...args: Args): number;
    begin(): VecStack;
    end(): void;
    return(id: number): number;
    push(x: number, y: number, z: number, w: number): number;
    pushScalar(x: number): number;
    pushSpread(x: number): number;
    spread(v: number, x: number): number;
    pushGlobal(x: number, y: number, z: number, w: number): number;
    length(id: number): number;
    reflect(toPoint: number, normal: number): number;
    sqrlength(id: number): number;
    dot(lh: number, rh: number): number;
    distance(lh: number, rh: number): number;
    sqrdistance(lh: number, rh: number): number;
    normalize(id: number): number;
    eqz(id: number): boolean;
    x(ptr: number): number;
    y(ptr: number): number;
    z(ptr: number): number;
    w(ptr: number): number;
    setx(ptr: number, v: number): VecStack;
    sety(ptr: number, v: number): VecStack;
    setz(ptr: number, v: number): VecStack;
    setw(ptr: number, v: number): VecStack;
    copy(dst: number, src: number): number;
    set(id: number, x: number, y: number, z: number, w: number): number;
    add(lh: number, rh: number): number;
    sub(lh: number, rh: number): number;
    mul(lh: number, rh: number): number;
    div(lh: number, rh: number): number;
    scale(id: number, scale: number): number;
    lerp(lh: number, rh: number, t: number): number;
    apply(id: number, f: (x: number) => number): number;
    apply2(lh: number, rh: number, f: (x: number, y: number) => number): number;
}
//# sourceMappingURL=vecstack.d.ts.map